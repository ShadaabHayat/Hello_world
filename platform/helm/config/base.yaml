# All keys must be flat.
connector.class: "io.confluent.connect.s3.S3SinkConnector"
errors.tolerance: "all"
flush.size: "3"
key.converter: "org.apache.kafka.connect.storage.StringConverter"
key.converter.schemas.enable: true
locale: "en-US"
partition.field.format.path: true
partition.field.name: "rdc, env"
partitioner.class: "com.canelmas.kafka.connect.FieldAndTimeBasedPartitioner"
path.format: "'year'=YYYY/'month'=MM/'day'=dd"
predicates: "match_resources_devicegroup_devices_and_end_system_topic_name"
predicates.match_resources_devicegroup_devices_and_end_system_topic_name.pattern: "aicore.public.resources_devicegroup_devices|aicore.public.end_systems"
predicates.match_resources_devicegroup_devices_and_end_system_topic_name.type: "org.apache.kafka.connect.transforms.predicates.TopicNameMatches"
s3.bucket.name: "uztna-data-bucket-ai-dev"
s3.credentials.provider.class: "io.confluent.connect.s3.auth.AwsAssumeRoleCredentialsProvider"
s3.credentials.provider.sts.role.arn: "$INGESTION_STS_ROLE_ARN"
s3.credentials.provider.sts.role.external.id: "$INGESTION_STS_EXTERNAL_ID"
s3.credentials.provider.sts.role.session.name: "$INGESTION_STS_SESSION_NAME"
s3.region: "us-east-1"
schema.compatibility: "NONE"
storage.class: "io.confluent.connect.s3.storage.S3Storage"
timestamp.extractor: "RecordField"
timestamp.field: "last_modified_at"
timezone: "UTC"
transforms: "InsertRDCInfo, InsertEnvInfo, Mask_aicore_public_users_user, Mask_aicore_public_resources_device"
transforms.InsertEnvInfo.static.field: "env"
transforms.InsertEnvInfo.static.value: "feature"
transforms.InsertEnvInfo.type: "org.apache.kafka.connect.transforms.InsertField${ESCAPE_CHAR}Value"
transforms.InsertRDCInfo.static.field: "rdc"
transforms.InsertRDCInfo.static.value: "feature-3"
transforms.InsertRDCInfo.type: "org.apache.kafka.connect.transforms.InsertField${ESCAPE_CHAR}Value"
transforms.InsertTimeStamp.predicate: "match_resources_devicegroup_devices_and_end_system_topic_name"
transforms.InsertTimeStamp.timestamp.field: "last_modified_at"
transforms.InsertTimeStamp.type: "org.apache.kafka.connect.transforms.InsertField${ESCAPE_CHAR}Value"
transforms.Mask_aicore_public_end_system.mask.fields: "mac_address,user_name,host_name"
transforms.Mask_aicore_public_end_system.topic.name: "aicore.public.end_systems"
transforms.Mask_aicore_public_end_system.type: "org.extremenetworks.com.MaskCustomFields${ESCAPE_CHAR}Value"
transforms.Mask_aicore_public_resources_device.mask.fields: "model_name,model_number,preshared_key,mac_address,mac_oui,created_by_email,code,name"
transforms.Mask_aicore_public_resources_device.topic.name: "aicore.public.resources_device"
transforms.Mask_aicore_public_resources_device.type: "org.extremenetworks.com.MaskCustomFields${ESCAPE_CHAR}Value"
transforms.Mask_aicore_public_users_user.mask.fields: "password,email,first_name,last_name,secret_2fa_key,scim_username"
transforms.Mask_aicore_public_users_user.topic.name: "aicore.public.users_user"
transforms.Mask_aicore_public_users_user.type: "org.extremenetworks.com.MaskCustomFields${ESCAPE_CHAR}Value"
transforms.tsFormat.field: "last_modified_at"
transforms.tsFormat.format: "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
transforms.tsFormat.predicate: "match_resources_devicegroup_devices_and_end_system_topic_name"
transforms.tsFormat.target.type: "string"
transforms.tsFormat.type: "org.apache.kafka.connect.transforms.TimestampConverter${ESCAPE_CHAR}Value"
value.converter: "io.confluent.connect.avro.AvroConverter"
value.converter.schema.registry.url: "http://aicore-kafka-schema-registry:8081"
value.converter.schemas.enable: false